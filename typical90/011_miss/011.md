# 小課題 2 の解き方

「どの仕事を完遂するか」の選び方は$2^N$通りあるが、これに対して"計画が実行可能か"を高速に判定すれば解ける。

仕事を全部やるのに最も良い戦略は「締め切りが早い順に取り掛かる」ことである。この理由は、締め切りの速さが逆連しているところがあれば、締め切りが遅い仕事をあとに移動させた方が確実に良くなるからである。

## 小課題 3 の解き方

小課題 2 では「完遂する仕事の組み合わせが同じなら、締め切りの早い順にやった方がよい」という性質を使った。つまり、締め切りの早い順に仕事を見ていき、それぞれに対して

1. 今すぐ遂行する
1. その仕事を捨てるか

を選ぶことになる。

この手段をとった場合の「報酬の最大値」は DP を用いて計算できる。(仕事は締め切りの早い順に並べ替えられている)

dp[どこまで仕事を見終わったか][合計仕事時間]=(報酬の最大値)

という風にして dp を計算していく。

このとき、dp[i][j]$(1 \le i \le N )$の値は次のようになる。

- $j < C_i$または$j > D_i$のとき: 直前の決断は「仕事 i を捨てる」しかありえないので、
  $$dp[i][j]=dp[i-1][j]$$
- $C_i \le j \le D_i$のとき: 直前の決断は「仕事 i を今すぐ遂行する」と「仕事 i を捨てる」のどちらでもよいので
  $$dp[i][j]=max(dp[i-1][j-C_i]+S_i)$$

答えは dp[N][?]の最大値であり、計算量は$\mathcal{O}(N \cdot \max D)$

## 想定コード

```cpp
for (int i = 0; i < N; i++) {
		for (int j = 0; j <= 5000; j++) {
			// 仕事 i + 1 をやらない場合
			dp[i + 1][j] = max(dp[i + 1][j], dp[i][j]);
			// 仕事 i + 1 をやる場合
			if (j + C[i + 1] <= D[i + 1]) {
				dp[i + 1][j + C[i + 1]] = max(dp[i + 1][j + C[i + 1]], dp[i][j] + S[i + 1]);
			}
		}
	}
```
