# 問題の考え方

辞書順最初なものを求めるときは貪欲法が有効である

# 解説

1 文字目が'b'~'z'であるものはどんなにその後の文字がどんなに辞書順で早くても、1 文字目が'a'である文字列には勝てない。したがって、辞書順最小なものは以下の条件を満たす。

1. 作れる文字列の中で、1 文字目が最も早い('a'に近い)
1. 1 を満たす文字列の中で、2 文字目が最も早い('a'に近い)
1. 2 を満たす文字列の中で、3 文字目が最も早い('a'に近い) ...[以下略]

そこで、「次の文字におけるものとして最も早い文字 ch」を貪欲に付け足すことを繰り返すことで
ことが求まる。よって、置ける条件は「前置いた文字の右にある文字 ch の中で全部選んだら K 文字以上になること」となる。(K-1 文字未満しかないなら K 文字の文字列を作れない)

## 具体的なアルゴリズム

<hr>

文字列 S の中で、最後にとった文字の添字を j とする (j = -1 と初期化しておく)

- 各 i=0,1,…,K−1 に対して
  - 文字 a, b, ... の順に見て行って、次の条件を満たす最小の k を求める
  - S[k] がその文字である
  - $k \geq j$である
  - S[k:] は K−i 文字以上ある
  - そのような k が存在するならば、答えに S[k] を加える、存在しなければ次の文字を見る

<hr>
このアルゴリズムの計算量は、$M$をアルファベットの種類数として$\mathcal{O}(NMK)$となるので間に合わない

## 改善

「前選んだ文字の右にある文字 c の中で最左のもの」を単純に全探索しているので$\mathcal{O}(N)$かかっている。ここで、これを$\mathcal{O}(1)$で求めるために前処理として、次の配列`nex`を求める。

<hr>

`nex[i][c]` ← 文字列 S の i 文字目以降で、文字 c が出現する最小の添え字(存在しない場合は N)

<hr>

この配列は$\mathcal{O}(NM)$の計算量で求めることができ、先ほどの貪欲法において k を探索する部分の計算量は $\mathcal{O}(1)$ にできるので、全体の計算量は $\mathcal{O}(MS)$ へと改善される。

# コード

## nex の求め方

```cpp
vector<vector<int>> calc_next(const string &S) {
  int N = (int)S.size();

  vector<vector<int> > res(N + 1, vector<int>(26, N));

  for(int i = N - 1; i >= 0; --i){
    res[i] = res[i + 1];

    res[i][S[i] - 'a'] = i;
  }
  return res;
}
```

## 貪欲法

```cpp
int j = -1;
for(int i = 0; i < K; ++i){
  for(char ch = 'a'; ch <= 'z'; ++ch){
    int k = nex[j + 1][c - 'a'];
    if(N - k)
  }
}
```
